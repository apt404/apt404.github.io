<html>

<head>
    <meta charset="utf-8">
    
    <title>APT404-不作恶</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="/favicon/favicon.ico">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/tagplugins.css">
    <link rel="stylesheet" href="/css/highlight.css">
    


    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="APT404-不作恶" type="application/atom+xml" />
    
</head>

<body>
  <div class="blog-header">
   <a id="menu-nav-icon"><img src="/image/menu.png"/></a>
   <div class="nav-container">
     <nav id="main-nav">
       
         <a class="main-nav-link" href="/">Home</a>
       
         <a class="main-nav-link" href="/archives">Archives</a>
       
     </nav>
   </div>
   <!--
   <div id="search-form-wrap">
     <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://apt404.github.io"></form>
   </div>
 -->
    <h1 class="blog-title">APT404-不作恶</h1>
    <p class="lead blog-description">在路上，一直在路上！</p>
</div>

  <div id='main-part'>
      
    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2017/10/26/privilege-local/">Win & Linux 本地提权脑图</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2017-10-26
        
            by klion
        
    </p>

    

    <!-- Content -->
    <p><img src="/img/privilege localhost.jpg" alt=""><br></p>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    


<div class="blog-categories-container">
    <span><img src="/image/categoriesicon.png" alt=""/></span> 
    <a href="/categories/privilege/">privilege</a>
</div>


    


<div class="blog-tags-container">
    <span><img src="/image/tagsicon.png" alt=""/></span>
    <a href="/tags/privilege/">#privilege</a>
</div>




</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2017/10/26/ettercap/">宝刀未老之 Ettercap 基础使用 [一]</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2017-10-26
        
            by klion
        
    </p>

    

    <!-- Content -->
    <p><br><br>0x01 关于ettercap<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ettercap 确实已经非常老了,也确实是那个时代的经典,而且差不多三四年这个项目也都没再更新过了</span><br><span class="line">对于一些防护并不是特别好的内网,依然非常实用,千万不要觉得工具老就没有它的应用场地,那样你就真的错了,如果真是这样,就不会有这么多的二次深度开发了</span><br><span class="line">大家可能也发现了,像这类的工具我基本都是在模拟真实的生产机器环境上编译安装的</span><br><span class="line">具体原因大家想必都很清楚,像这类基于二层的arp嗅探是没法直接在远程做的,毕竟不是直接处在目标的vpn内网中</span><br><span class="line">socks代理再牛逼,它也只是个基于端口的四层代理,并不是vpn,所以,是没法直接在本地嗅远程的arp的,至于GRE隧道,咱们抽空再另说</span><br><span class="line">话不多讲,直奔今天的主题,ettercap基础使用,注意,此次仅仅是基础使用</span><br></pre></td></tr></table></figure></p>
<p>0x02 开启本地的路由转发<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line"># cat /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure></p>
<p>0x03 基础演示环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CentOS release 6.9 (Final)  x86-64 ip: 192.168.3.4  接口名称: eth2  ettercap所在机器</span><br><span class="line">win2008r2 			   ip: 192.168.3.23 </span><br><span class="line">win7cn				   ip: 192.168.3.8</span><br></pre></td></tr></table></figure></p>
    <!-- Only display the Read More link if we are displaying an excerpt -->
    
        <p id="readmore">
            <a href="/2017/10/26/ettercap/">
                Read More >>>
            </a>
        </p>
    

    <hr />

    


<div class="blog-categories-container">
    <span><img src="/image/categoriesicon.png" alt=""/></span> 
    <a href="/categories/ettercap/">ettercap</a>
</div>


    


<div class="blog-tags-container">
    <span><img src="/image/tagsicon.png" alt=""/></span>
    <a href="/tags/ettercap/">#ettercap</a>
</div>




</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2017/10/25/arpoison/">Arp攻防之arpoison</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2017-10-25
        
            by klion
        
    </p>

    

    <!-- Content -->
    <p><br><br>0x01 依然是先开启本地的路由转发<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/sysctl.conf</span><br><span class="line">  net.ipv4.ip_forward=1</span><br><span class="line"># sysctl -p</span><br></pre></td></tr></table></figure></p>
<p>0x02 演示环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">centOS 6.8 x86_64	mac: 00:0C:29:C4:A0:95	ip : 192.168.3.4</span><br><span class="line">win7cn 			mac: 00-0C-29-3B-BF-A8  ip : 192.168.3.8</span><br><span class="line">win2008r2cn		mac: 00-0C-29-6C-55-D2  ip : 192.168.3.23</span><br><span class="line">网关			mac: dc-ee-06-96-b7-b7	ip : 192.168.3.1</span><br></pre></td></tr></table></figure></p>
<p>0x03 下载编译 arpoison<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># yum install epel-release -y</span><br><span class="line"># yum install libnet libnet-devel -y</span><br><span class="line"># wget http://www.arpoison.net/arpoison-0.7.tar.gz</span><br><span class="line"># tar xf arpoison-0.7.tar.gz</span><br><span class="line"># cd arpoison-0.7</span><br><span class="line"># gcc arpoison.c /usr/lib64/libnet.so -o arpoison</span><br><span class="line"># cp arpoison /usr/bin/</span><br><span class="line"># arpoison -h</span><br></pre></td></tr></table></figure></p>
    <!-- Only display the Read More link if we are displaying an excerpt -->
    
        <p id="readmore">
            <a href="/2017/10/25/arpoison/">
                Read More >>>
            </a>
        </p>
    

    <hr />

    


<div class="blog-categories-container">
    <span><img src="/image/categoriesicon.png" alt=""/></span> 
    <a href="/categories/arpoison/">arpoison</a>
</div>


    


<div class="blog-tags-container">
    <span><img src="/image/tagsicon.png" alt=""/></span>
    <a href="/tags/arpoison/">#arpoison</a>
</div>




</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2017/10/24/dsniff/">熟练使用 Dsniff套件 进行嗅探</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2017-10-24
        
            by klion
        
    </p>

    

    <!-- Content -->
    <p><br><br>0x01 嗅探之前,我们有必要先来大致回顾下arp和rarp的基本通信流程,假设现在交换机中的mac地址表中暂时还没有任何对应关系<code>A机器想和B机器进行通信</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arp  地址解析协议,即通过ip找对应的mac:</span><br><span class="line">首先,A会先发arp请求[广播],向同一交换机下的所有其它机器询问,谁有B的这个ip</span><br><span class="line">当B收到这条消息时,就会再用arp响应给A,说,我有这个ip,我的mac是多少...</span><br><span class="line">当完成第一次正常通信之后就会在交换机的mac地址表中记录下这层指向对应关系</span><br><span class="line">后续就直接按照mac地址表中已有的指向来通信,而不再用广播询问,这就是一次极为常规的arp通信过程</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rarp  反向地址解析协议,即通过mac找对应的ip:</span><br><span class="line">理解完arp以后,我们再来看rarp,同样是先发请求,这个请求简单来讲也是一个广播,不过,在此广播中声明了自己的mac</span><br><span class="line">并请求任何收到此请求的rarp服务器分配一个ip,当同网段的rarp服务器收到此请求后会检查自己的rarp列表找到该mac对应的ip</span><br><span class="line">如果此mac的ip被找到,就直接响应对方使用,如果没找到,最后就会提示初始化失败</span><br></pre></td></tr></table></figure>
<p>0x02 关于arp欺骗最核心的细节<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假设同一交换机下有三台机器,分别为 A , B , C,正常情况下B和C的通信数据,A是不可能看到的</span><br><span class="line">但在ARP缓存表机制中存在一个缺陷,就是当请求主机收到ARP应答包后,不会去验证自己曾经是否向对方主机发送过ARP请求</span><br><span class="line">就直接就把这个应答包中的IP与MAC地址的对应关系更新到自己本地的ARP缓存表中,这时就直接导致原有IP的对应关系被恶意替换</span><br><span class="line">通俗点儿理解,也就是说,我强制刷新了对方的arp缓存对应关系,把原来ip的指向现在换成了我自己的地址</span><br><span class="line">导致现在B和C的通信都要先经过A,那么,我们在A上自然就可以顺利的看到C和B之间的所有明文通信数据,即实现了所谓的监听</span><br></pre></td></tr></table></figure></p>
    <!-- Only display the Read More link if we are displaying an excerpt -->
    
        <p id="readmore">
            <a href="/2017/10/24/dsniff/">
                Read More >>>
            </a>
        </p>
    

    <hr />

    


<div class="blog-categories-container">
    <span><img src="/image/categoriesicon.png" alt=""/></span> 
    <a href="/categories/dsniff/">dsniff</a>
</div>


    


<div class="blog-tags-container">
    <span><img src="/image/tagsicon.png" alt=""/></span>
    <a href="/tags/dsniff/">#dsniff</a>
</div>




</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2017/10/23/inetd-backdoor/">基于 Inetd 后门的简要分析及利用</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2017-10-23
        
            by klion
        
    </p>

    

    <!-- Content -->
    <p><br><br>0x01 理解<code>inetd</code>是干什么的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">通俗来讲就是一个监听外部网络请求 [就是一个socket] 的系统守护进程,其实有很多比较古老的服务都是基于此守护进程的</span><br><span class="line">具体怎么工作的呢,其实非常简单,当inetd接收到一个外部请求后,它会根据这个请求到自己的配置文件中去找到实际处理它的程序</span><br><span class="line">然后再把接收到的这个socket交给那个程序去处理,问题恰巧也就出在这里</span><br><span class="line">如果来自外部的某个socket是要执行一个可交互的shell [比如,我们已经在目标系统的inetd配置文件中事先定义好],这岂不是就相当于一个简易的bind型后门</span><br><span class="line">另外,关于使用inet的好处就是,不用每个服务都再单独起个进程,这样可以有效降低系统资源消耗,你甚至也可以一定程度上把它理解成linux中的&apos;svchost.exe&apos;进程</span><br></pre></td></tr></table></figure></p>
    <!-- Only display the Read More link if we are displaying an excerpt -->
    
        <p id="readmore">
            <a href="/2017/10/23/inetd-backdoor/">
                Read More >>>
            </a>
        </p>
    

    <hr />

    


<div class="blog-categories-container">
    <span><img src="/image/categoriesicon.png" alt=""/></span> 
    <a href="/categories/inetd/">inetd</a>
</div>


    


<div class="blog-tags-container">
    <span><img src="/image/tagsicon.png" alt=""/></span>
    <a href="/tags/inetd/">#inetd</a>
</div>




</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2017/10/19/cowrie/">蜜罐学习之Ssh [ Cowrie ]</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2017-10-19
        
            by klion
        
    </p>

    

    <!-- Content -->
    <p><br><br>0x01 蜜罐是什么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">蜜罐其实就是一台无人使用但却被严密监控的网络主机,里面包含着各类虚假的高价值资源和一些已知漏洞,以此吸引入侵者来入侵该主机</span><br><span class="line">并且在被入侵的过程中,实时记录和审计入侵者的所有入侵攻击流量,行为和数据,以此了解入侵者的攻击方式,手段和目的,便于后期快速完成对其的溯源,取证工作</span><br></pre></td></tr></table></figure></p>
<p>0x02 蜜罐的一些主要构成模块<br>按实现大概逻辑划分:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">控制,将入侵者牢牢控制在指定的网络范围中,使其不能再以此机器作为跳板来攻击其它的机器</span><br><span class="line">捕获,把入侵者在入侵过程中所产生的各种流量捕获住</span><br><span class="line">分析,将捕获到的各种数据存到数据库或者其它指定地方,便于后续还原其详细的入侵攻击过程</span><br></pre></td></tr></table></figure></p>
<p>按具体实现过程划分:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">监控各种主机项,如,进程,文件,注册表,网络...</span><br><span class="line">同时提交给入侵检测,以识别其更详细的入侵手段,并对整个入侵过程做详细记录</span><br><span class="line">入侵数据汇总分析,其实就是把上述两步所得到的各种数据进行集中分析,最后,勾勒出完整的入侵轨迹画像</span><br></pre></td></tr></table></figure></p>
    <!-- Only display the Read More link if we are displaying an excerpt -->
    
        <p id="readmore">
            <a href="/2017/10/19/cowrie/">
                Read More >>>
            </a>
        </p>
    

    <hr />

    


<div class="blog-categories-container">
    <span><img src="/image/categoriesicon.png" alt=""/></span> 
    <a href="/categories/netsh/">netsh</a>
</div>


    


<div class="blog-tags-container">
    <span><img src="/image/tagsicon.png" alt=""/></span>
    <a href="/tags/netsh/">#netsh</a>
</div>




</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2017/10/17/win-event-powershell/">Win入侵日志处理之powershell</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2017-10-17
        
            by klion
        
    </p>

    

    <!-- Content -->
    <p><br><br>0x01 前言:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">很久之前,我们说过如何利用win自带的wevtutil工具来处理各种入侵日志</span><br><span class="line">但那有个很致命的缺点,就是删除的时候是一下全给干掉了,这很显然不是我们想要的</span><br><span class="line">今天我们就再来介绍另外一种相对[只是相对比较好,个人认为也并不是特别好,但值得在此基础上改进]比较好的处理方式</span><br><span class="line">也正是我之前说的利用powershell来帮我们搞,具体实现如下</span><br></pre></td></tr></table></figure></p>
<p>0x02 首先,我们有必要先来简单了解下windows的svchost进程是干什么的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">简单通俗来讲,svchost主要是用来实现服务进程数据共享,以此来减少系统资源消耗的这么一个东西,下面挂靠的程序可能同时有很多个</span><br><span class="line">说白点,其内部其实是作为线程[核心就在这儿]来运行的,关于更详细的简介,可直接参考维基百科上对其的说明</span><br></pre></td></tr></table></figure></p>
<p>0x03 如果实在想自己手工实现该功能的话,大体思路如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">找目标系统中Win事件日志服务的进程名,一般都是在svchost下</span><br><span class="line">并从该进程中获取所对应的Win 事件日志服务线程ID</span><br><span class="line">想办法杀掉这些id所对应的线程,以达到让目标系统日志服务无法正常工作的目的,这样系统就无法再搜集日志了</span><br></pre></td></tr></table></figure></p>
    <!-- Only display the Read More link if we are displaying an excerpt -->
    
        <p id="readmore">
            <a href="/2017/10/17/win-event-powershell/">
                Read More >>>
            </a>
        </p>
    

    <hr />

    


<div class="blog-categories-container">
    <span><img src="/image/categoriesicon.png" alt=""/></span> 
    <a href="/categories/active-directory-pentest/">active directory pentest</a>
</div>


    


<div class="blog-tags-container">
    <span><img src="/image/tagsicon.png" alt=""/></span>
    <a href="/tags/active-pentest/">#active pentest</a>
</div>




</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2017/10/12/bypasswaf-for-webshell/">全方位构造免杀 Webshell 小结[一]</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2017-10-12
        
            by klion
        
    </p>

    

    <!-- Content -->
    <p><br><br>前言:<br>&nbsp;&nbsp;&nbsp;&nbsp;本文几乎涵盖了市面上所有已知的webshell免杀手段,自己也很清楚,有些东西一旦公布出去,基本就活不太久了,但好在技巧是死的,人是活的,基于前人的优秀经验基础上所衍生出来的更加刁钻诡异的思路才是最珍贵的,始终坚信,对抗是持续的,shell也是永远杀不完的…<br><br><br>0x01 首先就是基于各类最常规的命令和代码执行函数的花样变形<code>如,拆分重组,动态执行,以此来躲避静态特征检测</code>,不过像有些高危函数默认就会被运维们禁掉,甚至高版本的php默认已经不让执行系统命令[如,php7],万一再开了安全模式,就更费劲了</p>
<p>php中一些常见的执行类型函数:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">system()</span><br><span class="line">exec()</span><br><span class="line">shell_exec()</span><br><span class="line">passthru()</span><br><span class="line">proc_open()</span><br><span class="line"><span class="string">``</span> 反引号执行系统命令</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php $_POST[<span class="string">'fun'</span>]($_REQUEST[<span class="string">'req'</span>]);?&gt;</span><br></pre></td></tr></table></figure>
    <!-- Only display the Read More link if we are displaying an excerpt -->
    
        <p id="readmore">
            <a href="/2017/10/12/bypasswaf-for-webshell/">
                Read More >>>
            </a>
        </p>
    

    <hr />

    


<div class="blog-categories-container">
    <span><img src="/image/categoriesicon.png" alt=""/></span> 
    <a href="/categories/webshell/">webshell</a>
</div>


    


<div class="blog-tags-container">
    <span><img src="/image/tagsicon.png" alt=""/></span>
    <a href="/tags/webshell/">#webshell</a>
</div>




</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2017/09/23/cobalt-strike/">Cobalt Strike 快速上手 [ 一 ]</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2017-09-23
        
            by klion
        
    </p>

    

    <!-- Content -->
    <p><br><br>0x01 关于 Cobalt Strike<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一款非常优秀的后渗透平台 [ 谁用谁知道,嘿嘿……说不好用的唯一原因,可能就是很多用法还没有被自己挖掘出来,因为不会用,所以,才会感觉不好用 ]</span><br><span class="line">工具基于java,大部分功能在改进的基础上还是相对比较实用的,非常适合团队间协同作战</span><br><span class="line">更多详情请自行参考官网,这里就不啰嗦了,以下全部简称&apos;cs&apos;</span><br></pre></td></tr></table></figure></p>
<p>0x02 基础环境简介:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kali 	  		实际控制端		ip:192.168.1.144</span><br><span class="line">ubuntu 16.04 		自己公网的vps    	ip:53.3.3.6		</span><br><span class="line">win2008R2 		目标机器			ip:192.168.1.191</span><br><span class="line">centos6.9 		已控肉鸡			ip:192.168.1.199</span><br><span class="line">win7cn			另一台肉鸡		ip:192.168.1.123</span><br></pre></td></tr></table></figure></p>
<p>0x03 先来快速预览cs最基本的一些模块具体用途:</p>
<p>团队服务器[teamserver]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主要是为了方便一个渗透团队内部能够及时共享所有成员的所有渗透信息,加强成员间的交流协作,以此提高渗透效率</span><br><span class="line">也就是说,正常情况下一个团队只需要起一个团队服务器即可,团队中的所有成员只需要拿着自己的cs客户端登录到团体服务器就能轻松实现协同作战</span><br><span class="line">当然,实际中可能为了尽可能久的维持住目标机器权限,还会习惯性的多开几个团队服务器,防止出现意外情况</span><br><span class="line">另外,团体服务器最好运行在linux平台上[本次演示所用的团队服务器系统为ubuntu 16.04]</span><br></pre></td></tr></table></figure></p>
    <!-- Only display the Read More link if we are displaying an excerpt -->
    
        <p id="readmore">
            <a href="/2017/09/23/cobalt-strike/">
                Read More >>>
            </a>
        </p>
    

    <hr />

    


<div class="blog-categories-container">
    <span><img src="/image/categoriesicon.png" alt=""/></span> 
    <a href="/categories/cobalt-strike/">cobalt strike</a>
</div>


    


<div class="blog-tags-container">
    <span><img src="/image/tagsicon.png" alt=""/></span>
    <a href="/tags/cobalt-strike/">#cobalt strike</a>
</div>




</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2017/09/22/snortpentest/">入侵检测学习 Snort [一]</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2017-09-22
        
            by klion
        
    </p>

    

    <!-- Content -->
    <p><br><br>0x01 关于Snort<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">业界相对比较出名年头也比较久的一款基于网络的开源入侵检测工具</span><br><span class="line">不过,比较适合中小型网络 [在流量不是非常大的情况下还是很不错的选择],规则配置灵活,实战适用性相对较好</span><br><span class="line">只是,实在不知道为什么要弄一头猪做logo,这文化差异大的有点儿着实让人无法理解 :)</span><br></pre></td></tr></table></figure></p>
<p>0x02 理解snort的最基本的工作流程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">内网中的数据 -&gt; 数据嗅探[让内网中其它机器上的数据流过自己] -&gt; 进行各种预处理[防止数据逃逸] -&gt; 规则检测引擎 -&gt; 处理报警/日志 </span><br><span class="line">											    |		  |</span><br><span class="line">										      匹配规则库	  存到数据库或者写到日志文件中</span><br></pre></td></tr></table></figure></p>
<p>0x03 模块具体作用简介<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据包嗅探,让其它机器上的指定数据包都经过自己,以便snort分析数据,同样,用的也是libpcap库,包括在其它很多linux平台嗅探工具你都能看到它的身影</span><br><span class="line">预处理,包重组预处理器,主要是为了防止攻击包被拆分逃避Snort的检测,另一个是协议编码预处理器,主要负责把数据包协议解码成一个统一的格式,再丢给检测模块,最后一个是协议异常检测预处器</span><br><span class="line">规则匹配检测,也就是当预处理把数据包丢过来以后,规则引擎会将这些数据包逐个和规则库进行匹配,一旦发现数据包内容与某条规则匹配,就丢给报警模块去处理</span><br><span class="line">报警/日志模块,规则引擎将数据丢给报警模块以后,报警模块会根据snort事先定义好的规则动作(alert,log...)对其进行不同的处理(写到数据库或日志文件中)</span><br></pre></td></tr></table></figure></p>
    <!-- Only display the Read More link if we are displaying an excerpt -->
    
        <p id="readmore">
            <a href="/2017/09/22/snortpentest/">
                Read More >>>
            </a>
        </p>
    

    <hr />

    


<div class="blog-categories-container">
    <span><img src="/image/categoriesicon.png" alt=""/></span> 
    <a href="/categories/snort/">snort</a>
</div>


    


<div class="blog-tags-container">
    <span><img src="/image/tagsicon.png" alt=""/></span>
    <a href="/tags/snort/">#snort</a>
</div>




</div>
</div>




<div id="page-nav">
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
</div>



  </div>
  <!-- Footer -->
  <div id="footer">
  <div id="footer-social">
    
    
    
    
    
    
</div>

  <p id="footer-info">
    &copy; 2018 APT-404<br>
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> -
    Theme <a href="https://github.com/Suolawangzai/hexo-theme-nebula" target="_blank">nebula</a>
  </p>

  <div id="busuanzi">
    <span id="busuanzi_container_site_pv">
      &hearts;
    Total visits: <span id="busuanzi_value_site_pv"></span>
    </span>
  </div>
  <!--
  <div id="footer-info">
    &copy; 2018 APT-404<br>
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
  </div>
-->
</div>

  <!-- After footer scripts -->
  <!-- Disqus Comments -->


<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="/js/main.js"></script>

</body>

</html>
